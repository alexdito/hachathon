package main

import (
	"database/sql"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"sync"
	"time"

	_ "github.com/lib/pq"
)

type Row struct {
	UserId    int    `json:"user_id"`
	Timestamp string `json:"timestamp"`
	Category  string `json:"category"`
	Card      string `json:"card"`
	Amount    int    `json:"amount"`
}

type Reports struct {
	Report map[int]Report
}

type Report struct {
	UserId           int
	Sum              int
	CategoriesSum    map[string]int
	CategoriesAmount map[string]int
}

func (reports *Reports) CalculateSumReports() {
	for _, report := range reports.Report {
		if thisReport, ok := reports.Report[report.UserId]; ok {
			thisReport.Sum = report.getSum()
			reports.Report[report.UserId] = thisReport
		}
	}
}

func (report *Report) getSum() int {
	for _, v := range report.CategoriesSum {
		report.Sum += v
	}

	return report.Sum
}

var wg sync.WaitGroup

func main() {
	start := time.Now()
	var rows []Row

	jsonFile, err := os.Open("transactions.json")
	defer jsonFile.Close()

	if err != nil {
		fmt.Println(err)
	}

	byteValue, _ := ioutil.ReadAll(jsonFile)
	json.Unmarshal(byteValue, &rows)

	fmt.Println(fmt.Sprintf("Parse Json: %s", time.Since(start)))

	reports := Reports{}
	reports.Report = make(map[int]Report)

	for i := 0; i < len(rows); i++ {

		if _, isExist := reports.Report[rows[i].UserId]; !isExist {
			reports.Report[rows[i].UserId] = Report{UserId: rows[i].UserId, CategoriesSum: make(map[string]int), CategoriesAmount: make(map[string]int)}
		}

		reports.Report[rows[i].UserId].CategoriesAmount[rows[i].Category] += 1
		reports.Report[rows[i].UserId].CategoriesSum[rows[i].Category] += rows[i].Amount
	}

	defer reports.CalculateSumReports()

	wg.Add(3)

	fmt.Println(reports)

	go reports.GenerateJson()
	go reports.GenerateCsv()
	go reports.CreateRows()

	wg.Wait()

	fmt.Println(fmt.Sprintf("General time: %s", time.Since(start)))
}

func (reports *Reports) GenerateJson() {
	start := time.Now()

	result, err := json.Marshal(reports)

	if err != nil {
		log.Println(err)
	}

	reportFile, err := os.Create("report-transactions.json")

	if err != nil {
		fmt.Println(err)
	}

	reportFile.Write(result)

	fmt.Println("Generated report-transactions.json")

	reportFile.Close()

	fmt.Println(fmt.Sprintf("Generate Json: %s", time.Since(start)))

	defer wg.Done()
}

func (reports *Reports) GenerateCsv() {
	start := time.Now()

	fileCsv, err := os.Create("report-transactions.csv")
	defer fileCsv.Close()

	if err != nil {
		log.Fatalln("failed to open file", err)
	}

	writeCsv := csv.NewWriter(fileCsv)
	defer writeCsv.Flush()

	err = writeCsv.Write([]string{"User id", "General sum", "Category", "Number of category appearances", "Category sum"})

	for _, report := range reports.Report {
		for category, _ := range report.CategoriesSum {
			err = writeCsv.Write([]string{
				strconv.Itoa(report.UserId),
				strconv.Itoa(report.Sum),
				category,
				strconv.Itoa(report.CategoriesAmount[category]),
				strconv.Itoa(report.CategoriesSum[category]),
			})
		}
	}

	fmt.Println("Generated report-transactions.csv")

	fmt.Println(fmt.Sprintf("Generate Csv: %s", time.Since(start)))

	defer wg.Done()
}

func (reports *Reports) CreateRows()  {
	start := time.Now()

	postgresInfo := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
		"postgres", 5432, "golang", "golang", "golang")
	db, err := sql.Open("postgres", postgresInfo)

	if err != nil {
		panic(err)
	}
	defer db.Close()

	_, err = db.Exec(`DROP TABLE IF EXISTS REPORTS;`)
	if err != nil {
		panic(err)
	}
	_, err = db.Exec(`CREATE TABLE REPORTS (ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, USER_ID INT, SUM INT, CATEGORY_NAME VARCHAR(255), CATEGORY_SUM INT, CATEGORY_AMOUNT INT);`)
	if err != nil {
		panic(err)
	}

	var sqlStatement string

	for _, report := range reports.Report {
		for category, _ := range report.CategoriesSum {
			sqlStatement = `INSERT INTO REPORTS (USER_ID, SUM, CATEGORY_NAME, CATEGORY_SUM, CATEGORY_AMOUNT) VALUES ($1, $2, $3, $4, $5)`
			_, err = db.Exec(sqlStatement, report.UserId, report.Sum, category, report.CategoriesSum[category], report.CategoriesAmount[category])

			if err != nil {
				panic(err)
			}
		}
	}

	fmt.Println("Creating rows in DB")

	fmt.Println(fmt.Sprintf("Created at: %s", time.Since(start)))

	defer wg.Done()
}

